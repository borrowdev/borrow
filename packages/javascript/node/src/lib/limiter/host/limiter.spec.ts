import { limiter } from "./limiter.js";
import { Redis } from "@upstash/redis";
import fc from "fast-check";
import { UpstashRedisAdapter } from "./adapters/storage/redis/UpstashRedisAdapter.js";

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL_BORROW_LIMITER!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN_BORROW_LIMITER!,
});

// Note: Most of the schema is guaranteed by zod, so as a rule of thumb, TypeScript typings generated by zod are enough.
// When testing the schema, we'll only test custom zod logic that doesn't show up on typings such as `refine`, even though it's testing implementation details.
describe(
  "limiter function",
  {
    timeout: 20 * 1000,
  },
  () => {
    const invokeSecret = "valid-secret";
    const commonParams = {
      req: {
        invokeSecret,
        action: "check",
        userId: "test-user-id",
        key: "test-key",
        limiters: [
          {
            type: "fixed",
            interval: 60,
            maxRequests: 10,
          },
        ],
      },
      adapters: {
        storage: new UpstashRedisAdapter(redis),
      },
    } satisfies Parameters<typeof limiter>[0];

    beforeAll(() => {
      vi.stubEnv("BORROW_LIMITER_INVOKE_SECRET", invokeSecret);
      vi.useFakeTimers();
    });
    afterAll(async () => {
      vi.useRealTimers();
      await redis.flushdb();
    });

    it("should return 401 if the invoke secret is invalid", async () => {
      await fc.assert(
        fc.asyncProperty(fc.string(), async (invalidSecret) => {
          const result = await limiter({
            ...commonParams,
            req: {
              ...commonParams.req,
              invokeSecret: invalidSecret,
            },
          });
          expect(result).toMatchObject({
            result: "error",
            error: "UNAUTHORIZED",
            status: 401,
            timeLeft: null,
          });
          expect(result.message).toBeTypeOf("string");
          expect(result).not.toHaveProperty("tokensLeft");
        }),
        { numRuns: 3 }
      );
    });

    it("should refill tokens globally if 'keys' is null", async () => {
      const tokenLimiter = {
        type: "token",
        maxTokens: 157,
        tokensPerReplenish: 1,
        tokensCost: 5,
        interval: "day",
      } as const;

      // Simulate the tokens being used globally
      const { tokensLeft } = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: null,
          limiters: [
            {
              ...tokenLimiter,
              tokensCost: tokenLimiter.tokensCost * 3,
            },
          ],
        },
      });
      expect(tokensLeft).toBe(
        tokenLimiter.maxTokens - tokenLimiter.tokensCost * 3
      );

      const result = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "refillTokens",
          keys: null,
        },
      });
      expect(result).toMatchObject({
        result: "success",
        status: 200,
        timeLeft: null,
      });
      expect(result.message).toBeTypeOf("string");
      expect(result).not.toHaveProperty("tokensLeft");

      const afterResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: null,
          limiters: [tokenLimiter],
        },
      });
      expect(afterResult).toMatchObject({
        result: "success",
        status: 200,
        timeLeft: null,
        tokensLeft: tokenLimiter.maxTokens - tokenLimiter.tokensCost,
      });
    });

    it(
      "should refill tokens for the specified 'keys' if the action is 'refillTokens'",
      { timeout: 60 * 1000 },
      async () => {
        const tokenLimiter = {
          type: "token",
          maxTokens: 157,
          tokensPerReplenish: 1,
          tokensCost: 5,
          interval: "day",
        } as const;

        const keys = [
          {
            key: "test-key",
            userId: null,
          },
          {
            key: "test-key-2",
            userId: "test-userid-1",
          },
          {
            key: null,
            userId: "test-userid-2",
          },

          {
            key: "test-key-3",
            userId: null,
          },
          {
            key: "test-key-4",
            userId: "test-userid-3",
          },
          {
            key: null,
            userId: "test-userid-4",
          },
        ];

        // Simulate the tokens being used
        for (const key of keys) {
          await limiter({
            ...commonParams,
            req: {
              invokeSecret,
              action: "check",
              key: key.key,
              userId: key.userId,
              limiters: [tokenLimiter],
            },
          });
        }

        const afterResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "refillTokens",
            keys,
          },
        });
        expect(afterResult).toMatchObject({
          result: "success",
          status: 200,
          timeLeft: null,
        });
        expect(afterResult.message).toBeTypeOf("string");
        expect(afterResult).not.toHaveProperty("tokensLeft");

        // Check the tokens were actually refilled
        for (const k of keys) {
          const result = await limiter({
            ...commonParams,
            req: {
              invokeSecret,
              action: "check",
              key: k.key,
              userId: k.userId,
              limiters: [tokenLimiter],
            },
          });
          expect(result).toMatchObject({
            result: "success",
            status: 200,
            timeLeft: null,
            tokensLeft: tokenLimiter.maxTokens - tokenLimiter.tokensCost,
          });
        }
      }
    );

    it("should store usage globally if 'userId' and 'key' is not provided", async () => {
      const fixedLimiter = {
        type: "fixed",
        interval: 60,
        maxRequests: 10,
      } as const;

      // Store globally
      const globalResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: null,
          limiters: [fixedLimiter],
        },
      });
      expect(globalResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Store per userId + key
      const userKeyResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: "specific-key",
          userId: "specific-user",
          limiters: [fixedLimiter],
        },
      });
      expect(userKeyResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Check the globally stored usage is still the same (should increment once more)
      const secondGlobalResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: null,
          limiters: [fixedLimiter],
        },
      });
      expect(secondGlobalResult).toMatchObject({
        result: "success",
        status: 200,
      });
    });

    it("should store usage per user if 'userId' is provided and 'key' is not provided", async () => {
      const fixedLimiter = {
        type: "fixed",
        interval: 60,
        maxRequests: 10,
      } as const;
      const userId = "test-user-specific";

      // Store per userId
      const userResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: userId,
          limiters: [fixedLimiter],
        },
      });
      expect(userResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Store per userId + key
      const userKeyResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: "specific-key",
          userId: userId,
          limiters: [fixedLimiter],
        },
      });
      expect(userKeyResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Check the per userId stored usage is still the same (should increment once more)
      const secondUserResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: null,
          userId: userId,
          limiters: [fixedLimiter],
        },
      });
      expect(secondUserResult).toMatchObject({
        result: "success",
        status: 200,
      });
    });

    it("should store usage only by 'key' if it's the only identifier provided", async () => {
      const fixedLimiter = {
        type: "fixed",
        interval: 60,
        maxRequests: 10,
      } as const;
      const testKey = "test-unique-key";

      // Store per key
      const keyResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: testKey,
          userId: null,
          limiters: [fixedLimiter],
        },
      });
      expect(keyResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Store per userId + key (different userId)
      const userKeyResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: testKey,
          userId: "some-random-user",
          limiters: [fixedLimiter],
        },
      });
      expect(userKeyResult).toMatchObject({
        result: "success",
        status: 200,
      });

      // Check the per key stored usage is still the same (should increment once more)
      const secondKeyResult = await limiter({
        ...commonParams,
        req: {
          invokeSecret,
          action: "check",
          key: testKey,
          userId: null,
          limiters: [fixedLimiter],
        },
      });
      expect(secondKeyResult).toMatchObject({
        result: "success",
        status: 200,
      });
    });

    it("should return 400 if 'limiters' has non unique types", async () => {
      await fc.assert(
        fc.asyncProperty(fc.boolean(), async (includeValidLimiter) => {
          const duplicateLimiters: {
            type: "fixed" | "sliding";
            interval: number;
            maxRequests: number;
          }[] = [
            {
              type: "fixed",
              interval: 60,
              maxRequests: 10,
            },
            {
              type: "fixed", // Duplicate type
              interval: 120,
              maxRequests: 5,
            },
          ];

          if (includeValidLimiter) {
            duplicateLimiters.push({
              type: "sliding", // Different type
              interval: 60,
              maxRequests: 15,
            });
          }

          const result = await limiter({
            ...commonParams,
            req: {
              invokeSecret,
              action: "check",
              key: "test-key-duplicate",
              userId: "test-user-duplicate",
              limiters: duplicateLimiters,
            },
          });

          expect(result).toMatchObject({
            result: "error",
            error: "INVALID_PARAMS",
            status: 400,
            timeLeft: null,
          });
          expect(result.message).toContain("unique");
        }),
        { numRuns: 2 }
      );
    });

    describe("fixed limiter type", () => {
      it("should let requests pass if under the limit", async () => {
        const fixedLimiter = {
          type: "fixed",
          interval: 60,
          maxRequests: 3,
        } as const;

        const testKey = "fixed-under-limit";
        const testUserId = "user-fixed-under";

        // First request
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Second request - still under limit
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "success",
          status: 200,
        });
      });

      it("should block requests if over the limit", async () => {
        const fixedLimiter = {
          type: "fixed",
          interval: 60,
          maxRequests: 2,
        } as const;

        const testKey = "fixed-over-limit";
        const testUserId = "user-fixed-over";

        // First request
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Second request - reaching limit
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Third request - over limit
        const thirdResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(thirdResult).toMatchObject({
          result: "limited",
          status: 200,
        });
        expect(thirdResult.timeLeft).toBeTypeOf("number");
      });

      it("should reset the counter based on clock time", async () => {
        // Use minute as interval
        const fixedLimiter = {
          type: "fixed",
          interval: "minute",
          maxRequests: 1,
        } as const;

        const testKey = "fixed-reset";
        const testUserId = "user-fixed-reset";

        // Set the time to 1 second before next minute
        const now = new Date();
        const nearlyNextMinute = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          now.getHours(),
          now.getMinutes(),
          59 // 1 second before next minute
        );
        vi.setSystemTime(nearlyNextMinute);

        // First request - should pass
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Second request - should block (limit reached)
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "limited",
          status: 200,
        });

        // Advance to next minute
        const nextMinute = new Date(
          nearlyNextMinute.getFullYear(),
          nearlyNextMinute.getMonth(),
          nearlyNextMinute.getDate(),
          nearlyNextMinute.getHours(),
          nearlyNextMinute.getMinutes() + 1,
          1 // 1 second into next minute
        );
        vi.setSystemTime(nextMinute);

        // Third request - should pass (counter reset)
        const thirdResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [fixedLimiter],
          },
        });

        expect(thirdResult).toMatchObject({
          result: "success",
          status: 200,
        });
      });
    });

    describe("sliding limiter type", () => {
      it("should let requests pass if under the limit", async () => {
        const slidingLimiter = {
          type: "sliding",
          interval: 60,
          maxRequests: 3,
        } as const;

        const testKey = "sliding-under-limit";
        const testUserId = "user-sliding-under";

        // First request
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Second request - still under limit
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "success",
          status: 200,
        });
      });

      it("should block requests if over the limit", async () => {
        const slidingLimiter = {
          type: "sliding",
          interval: 60,
          maxRequests: 2,
        } as const;

        const testKey = "sliding-over-limit";
        const testUserId = "user-sliding-over";

        // First request
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Second request - reaching limit
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Third request - over limit
        const thirdResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(thirdResult).toMatchObject({
          result: "limited",
          status: 200,
        });
        expect(thirdResult.timeLeft).toBeTypeOf("number");
      });

      it("should reset the counter based on the sliding window", async () => {
        const slidingLimiter = {
          type: "sliding",
          interval: 60, // 1 minute interval
          maxRequests: 1,
        } as const;

        const testKey = "sliding-reset";
        const testUserId = "user-sliding-reset";

        // Set initial time
        const initialTime = new Date(2025, 0, 1, 12, 0, 0); // Jan 1, 2025, 12:00:00
        vi.setSystemTime(initialTime);

        // First request - should pass
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Advance time by 30 seconds (half the interval)
        const halfwayTime = new Date(2025, 0, 1, 12, 0, 30); // Jan 1, 2025, 12:00:30
        vi.setSystemTime(halfwayTime);

        // Second request - should be blocked (within sliding window)
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "limited",
          status: 200,
        });

        // Advance time by another 30 seconds (full interval has passed)
        const fullIntervalTime = new Date(2025, 0, 1, 12, 1, 1); // Jan 1, 2025, 12:01:01
        vi.setSystemTime(fullIntervalTime);

        // Third request - should pass (sliding window has moved past first request)
        const thirdResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [slidingLimiter],
          },
        });

        expect(thirdResult).toMatchObject({
          result: "success",
          status: 200,
        });
      });
    });

    describe("token limiter type", () => {
      it("should let requests pass if under token limit", async () => {
        const tokenLimiter = {
          type: "token",
          maxTokens: 10,
          tokensPerReplenish: 1,
          tokensCost: 3,
          interval: 60,
        } as const;

        const testKey = "token-under-limit";
        const testUserId = "user-token-under";

        // Request costs 3 tokens out of 10 available
        const result = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [tokenLimiter],
          },
        });

        expect(result).toMatchObject({
          result: "success",
          status: 200,
          tokensLeft: tokenLimiter.maxTokens - tokenLimiter.tokensCost,
        });
      });

      it("should block requests if not enough tokens", async () => {
        const tokenLimiter = {
          type: "token",
          maxTokens: 10,
          tokensPerReplenish: 1,
          tokensCost: 12, // More than available
          interval: 60,
        } as const;

        const testKey = "token-over-limit";
        const testUserId = "user-token-over";

        // Request costs 12 tokens but only 10 available
        const result = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [tokenLimiter],
          },
        });

        expect(result).toMatchObject({
          result: "limited",
          status: 200,
        });
        expect(result.tokensLeft).toBeTypeOf("number");
      });

      it("should replenish tokens based on the interval", async () => {
        const tokenLimiter = {
          type: "token",
          maxTokens: 10,
          tokensPerReplenish: 5,
          tokensCost: 2,
          interval: 60, // 1 minute
        } as const;

        const testKey = "token-replenish";
        const testUserId = "user-token-replenish";

        // Set initial time
        const initialTime = new Date(2025, 0, 1, 12, 0, 0);
        vi.setSystemTime(initialTime);

        // First request - costs full tokens (10)
        const firstResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [
              {
                ...tokenLimiter,
                tokensCost: 10, // Use all available tokens
              },
            ],
          },
        });
        expect(firstResult).toMatchObject({
          result: "success",
          status: 200,
          tokensLeft: 0,
        });

        // Second request - should be blocked (no tokens left)
        const secondResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [tokenLimiter],
          },
        });
        expect(secondResult).toMatchObject({
          result: "limited",
          status: 200,
        });

        // Advance time past the interval to trigger token replenishment
        const replenishTime = new Date(2025, 0, 1, 12, 1, 1); // 1 minute and 1 second later
        vi.setSystemTime(replenishTime);

        // Third request - should pass with replenished tokens
        const thirdResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [tokenLimiter],
          },
        });

        expect(thirdResult).toMatchObject({
          result: "success",
          status: 200,
          tokensLeft: tokenLimiter.tokensPerReplenish - tokenLimiter.tokensCost,
        });
      });
    });

    describe("borrow limiter type", () => {
      it("should let a borrow start and end if no active borrow exists", async () => {
        const borrowStartLimiter = {
          type: "borrow",
          timeout: 60,
          borrowAction: "start",
        } as const;

        const borrowEndLimiter = {
          type: "borrow",
          timeout: 60,
          borrowAction: "end",
        } as const;

        const testKey = "borrow-start-end";
        const testUserId = "user-borrow-start-end";

        // Start a borrow - should pass
        const startResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(startResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // End the borrow - should pass
        const endResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowEndLimiter],
          },
        });
        expect(endResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Start another borrow - should pass
        const secondStartResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(secondStartResult).toMatchObject({
          result: "success",
          status: 200,
        });
      });

      it("should not accumulate multiple borrows for the same key", async () => {
        const borrowStartLimiter = {
          type: "borrow",
          timeout: 60,
          borrowAction: "start",
        } as const;

        const borrowEndLimiter = {
          type: "borrow",
          timeout: 60,
          borrowAction: "end",
        } as const;

        const testKey = "borrow-multiple";
        const testUserId = "user-borrow-multiple";

        // Start a borrow - should pass
        const startResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(startResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Try to start another borrow - should be limited
        const secondStartResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(secondStartResult).toMatchObject({
          result: "limited",
          status: 200,
        });

        // End the borrow - should pass
        const endResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowEndLimiter],
          },
        });
        expect(endResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Start a new borrow - should pass
        const thirdStartResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(thirdStartResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // End the borrow multiple times - should pass
        for (let i = 0; i < 3; i++) {
          const multiEndResult = await limiter({
            ...commonParams,
            req: {
              invokeSecret,
              action: "check",
              key: testKey,
              userId: testUserId,
              limiters: [borrowEndLimiter],
            },
          });
          expect(multiEndResult).toMatchObject({
            result: "success",
            status: 200,
          });
        }

        // Start a new borrow - should pass
        const finalStartResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(finalStartResult).toMatchObject({
          result: "success",
          status: 200,
        });

        // Try to start another borrow - should be limited
        const finalDuplicateStartResult = await limiter({
          ...commonParams,
          req: {
            invokeSecret,
            action: "check",
            key: testKey,
            userId: testUserId,
            limiters: [borrowStartLimiter],
          },
        });
        expect(finalDuplicateStartResult).toMatchObject({
          result: "limited",
          status: 200,
        });
      });
    });

    describe("interval shortcuts", () => {
      it("should correctly translate interval shortcuts", async () => {
        const shortcuts = [
          { input: "minute", seconds: 60 },
          { input: "hour", seconds: 60 * 60 },
          { input: "day", seconds: 60 * 60 * 24 },
        ] as const;

        // Use fixed date for consistent results
        const fixedDate = new Date("2025-01-01T00:00:00Z");
        vi.setSystemTime(fixedDate);

        for (const shortcut of shortcuts) {
          const fixedLimiter = {
            type: "fixed" as const,
            interval: shortcut.input,
            maxRequests: 2,
          };

          const testKey = `shortcut-${shortcut.input}`;
          const testUserId = `user-shortcut-${shortcut.input}`;

          // Exhaust the limit with requests
          for (let j = 0; j < fixedLimiter.maxRequests; j++) {
            const passResult = await limiter({
              ...commonParams,
              req: {
                invokeSecret,
                action: "check",
                key: testKey,
                userId: testUserId,
                limiters: [fixedLimiter],
              },
            });

            expect(passResult).toMatchObject({
              result: "success",
              status: 200,
            });
          }

          // Next request should be limited
          const limitedResult = await limiter({
            ...commonParams,
            req: {
              invokeSecret,
              action: "check",
              key: testKey,
              userId: testUserId,
              limiters: [fixedLimiter],
            },
          });

          expect(limitedResult).toMatchObject({
            result: "limited",
            status: 200,
          });
          expect(limitedResult.timeLeft).toBeTypeOf("number");

          const expectedTime = shortcut.seconds;
          const actualTime = limitedResult.timeLeft;

          expect(actualTime).toBe(expectedTime);
        }
      });
    });
  }
);
